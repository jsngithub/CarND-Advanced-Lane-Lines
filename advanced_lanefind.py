"""
.
.
.
"""

import pickle
import cv2
import numpy as np
import gradient as gd
#import matplotlib.pyplot as plt
from moviepy.editor import VideoFileClip
import glob
import line

# load the camera calibration data
# generated by calibrate_camera.py
dist_pickle = pickle.load(open('dist_pickle.p', 'rb'))
mtx = dist_pickle['mtx']
dist = dist_pickle['dist']

# load / calculate warp factor
#M_pickle = pickle.load(open('M_pickle.p', 'rb'))
#M = M_pickle['M']
offset = 320
img_size = (720, 1280, 3)
src = np.float32([[236, img_size[0]], [1187, img_size[0]], [580, 460], [720, 460]])
dst = np.float32([[offset, img_size[0]], [img_size[1]-offset, img_size[0]],
                  [offset, 0], [img_size[1]-offset, 0]])
M = cv2.getPerspectiveTransform(src, dst)
Minv = cv2.getPerspectiveTransform(dst, src)

lanes = line.Line()

# calibrate image with the values derived from chessboard images
def calibrate_image(img, mtx, dist):
    return cv2.undistort(img, mtx, dist, None, mtx)    

# input: RGB image
def get_yellow_mask(img):
    #                 H   S    V 
    lower = np.array([15, 75,  75]) #15, 75, 75
    upper = np.array([30, 255, 255]) #30, 255, 255
    img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
    mask = cv2.inRange(img, lower, upper)
    img = cv2.cvtColor(img, cv2.COLOR_HSV2RGB)
    return mask

def get_white_mask(img):
    #                 H    S    V
    lower = np.array([0,   0,  128]) #0, 0, 190
    upper = np.array([255, 25, 255]) #255, 25, 255
    img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
    mask = cv2.inRange(img, lower, upper)
    img = cv2.cvtColor(img, cv2.COLOR_HSV2RGB)
    return mask    

def get_canny_mask(img):
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    #gray_blur = cv2.GaussianBlur(gray, (9, 9), 0)
    gray_blur = gray
    mask = cv2.Canny(gray_blur, 40, 80, L2gradient=False)
    return mask

def warp(img):
    warped = cv2.warpPerspective(img, M, img_size[:2][::-1])
    return warped

def delete_sky(mask):
    mask[0:480,:] = 0
    return mask

def find_lane(img, generate_examples=False):
    # calibrate image
    if (generate_examples): cv2.imwrite('output_images/1_original_image.jpg', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
    img = cv2.undistort(img, mtx, dist, None, mtx)
    if (generate_examples): cv2.imwrite('output_images/1_undistorted_example.jpg', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
        
    # keep the original undistorted copy
    orig = img.copy()
    
    # get and combine Canny and directional masks
    cmask = get_canny_mask(img)
    if (generate_examples): cv2.imwrite('output_images/3_canny.jpg', cmask)
    
    dmask = np.uint8(gd.dir_threshold(cv2.cvtColor(img, cv2.COLOR_RGB2GRAY), sobel_kernel=3, thresh=(0.6, 1.4)) * 255)
    if (generate_examples): cv2.imwrite('output_images/3_directional.jpg', dmask)
          
    cmask = cmask & dmask
    if (generate_examples): cv2.imwrite('output_images/3_canny_and_diretional.jpg', cmask)
    
    # dilate the mask to fill in the gaps
    cmask = cv2.dilate(cmask, np.ones((3,3), np.uint8), iterations=3)
    if (generate_examples): cv2.imwrite('output_images/3_canny_and_directional_dilate.jpg', cmask)
    
    # get while and yellow masks
    wmask = get_white_mask(img)
    if (generate_examples): cv2.imwrite('output_images/3_white.jpg', wmask)

    #wmask = cmask & wmask
    if (generate_examples): cv2.imwrite('output_images/3_wc.jpg', wmask)
    
    ymask = get_yellow_mask(img)
    if (generate_examples): cv2.imwrite('output_images/3_yellow.jpg', ymask)
    
    # erode the yellow mask
    ymask = cv2.erode(ymask, np.ones((3,3), np.uint8), iterations=1)
    if (generate_examples): cv2.imwrite('output_images/3_yellow_erode.jpg', ymask)
    
    # create the final combined mask
    mask = ymask | wmask
    if (generate_examples): cv2.imwrite('output_images/3_yellow_or_white.jpg', mask)
       
    # create B&W image to send to find_lines
    imgbw = np.zeros_like(img)
    imgbw[(mask==255)] = [255, 255, 255]
    if (generate_examples): cv2.imwrite('output_images/2_threshold_binary.jpg', cv2.cvtColor(imgbw, cv2.COLOR_RGB2GRAY))

    # crop the hood portion then warp the image
    imgbw = warp(cv2.cvtColor(imgbw, cv2.COLOR_RGB2GRAY))
    imgbw[670:] = 0
    if (generate_examples): cv2.imwrite('output_images/3_threshold_binary_warped.jpg', imgbw)
    
    img = warp(img)
    img[670:,:,:] = [0, 0, 0]
    
    return lanes.detect_lanes(orig, imgbw,
                              img, Minv, debug=generate_examples)

process_video = True

if (process_video):
    vf = glob.glob('*.mp4')
    #video_filenames = [vf[2], vf[0], vf[1]]
    video_filenames = [vf[2]]
    
    for name in video_filenames:
        output_filename = 'output_images/'+name
        video_in = VideoFileClip(name)
        video_out = video_in.fl_image(find_lane)
        video_out.write_videofile(output_filename, audio=False)
else:
    img = cv2.imread('test_images/test2.jpg')
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    output = find_lane(img, generate_examples=True)
    cv2.imwrite('output_images/5_final.jpg', cv2.cvtColor(output, cv2.COLOR_RGB2BGR))
























































